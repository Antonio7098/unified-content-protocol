# ID Generation

Block IDs in UCM are **content-addressed identifiers** with 96-bit collision resistance. This ensures deterministic, reproducible identification of content.

## BlockId Structure

```rust
/// Block identifier with 96 bits of entropy (12 bytes).
/// Format: `blk_<24 hex characters>`
pub struct BlockId(pub [u8; 12]);
```

### Format

- **Prefix**: `blk_`
- **Body**: 24 hexadecimal characters (12 bytes)
- **Total length**: 28 characters

```
blk_a1b2c3d4e5f6a1b2c3d4e5f6
└─┬─┘└──────────┬──────────┘
prefix    24 hex chars (96 bits)
```

## Creating Block IDs

### From Content (Recommended)

```rust
use ucm_core::Content;
use ucm_core::id::generate_block_id;

let content = Content::text("Hello, world!");

// Generate deterministic ID
let id = generate_block_id(&content, Some("intro"), None);
println!("{}", id); // blk_a1b2c3d4e5f6...

// Same content + role = same ID
let id2 = generate_block_id(&content, Some("intro"), None);
assert_eq!(id, id2);
```

### From Raw Bytes

```rust
use ucm_core::BlockId;

let id = BlockId::from_bytes([0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                               0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c]);
println!("{}", id); // blk_0102030405060708090a0b0c
```

### From Hex String

```rust
use ucm_core::BlockId;

let id = BlockId::from_hex("a1b2c3d4e5f6a1b2c3d4e5f6").unwrap();
```

### Parsing from String

```rust
use ucm_core::BlockId;
use std::str::FromStr;

let id: BlockId = "blk_a1b2c3d4e5f6a1b2c3d4e5f6".parse().unwrap();

// Or using FromStr
let id = BlockId::from_str("blk_a1b2c3d4e5f6a1b2c3d4e5f6").unwrap();
```

### Root Block ID

```rust
use ucm_core::BlockId;

let root = BlockId::root();
assert!(root.is_root());
println!("{}", root); // blk_ff00000000000000000000
```

## ID Generation Algorithm

Block IDs are generated by hashing:

1. **Namespace** (optional) - For multi-tenant isolation
2. **Content type** - The type discriminant (text, code, table, etc.)
3. **Semantic role** (optional) - The block's role in the document
4. **Normalized content** - The content after normalization

```rust
pub fn generate_block_id(
    content: &Content,
    semantic_role: Option<&str>,
    namespace: Option<&str>,
) -> BlockId {
    let mut hasher = Sha256::new();
    
    // Add namespace if present
    if let Some(ns) = namespace {
        hasher.update(ns.as_bytes());
        hasher.update(b":");
    }
    
    // Add content type discriminant
    hasher.update(content.type_tag().as_bytes());
    hasher.update(b":");
    
    // Add semantic role
    if let Some(role) = semantic_role {
        hasher.update(role.as_bytes());
    }
    hasher.update(b":");
    
    // Add normalized content
    let normalized = normalize_content(content);
    hasher.update(normalized.as_bytes());
    
    // Extract 96 bits from SHA256
    let hash = hasher.finalize();
    let mut id_bytes = [0u8; 12];
    id_bytes.copy_from_slice(&hash[..12]);
    
    BlockId(id_bytes)
}
```

## Determinism

IDs are **deterministic** - the same inputs always produce the same ID:

```rust
use ucm_core::Content;
use ucm_core::id::generate_block_id;

let content = Content::text("Hello");

// Same content + same role = same ID
let id1 = generate_block_id(&content, Some("intro"), None);
let id2 = generate_block_id(&content, Some("intro"), None);
assert_eq!(id1, id2);

// Different role = different ID
let id3 = generate_block_id(&content, Some("conclusion"), None);
assert_ne!(id1, id3);

// Different content = different ID
let content2 = Content::text("Hello!");
let id4 = generate_block_id(&content2, Some("intro"), None);
assert_ne!(id1, id4);
```

## Namespace Isolation

Namespaces enable multi-tenant scenarios:

```rust
use ucm_core::Content;
use ucm_core::id::generate_block_id;

let content = Content::text("Hello");

// Different namespaces = different IDs
let id_tenant_a = generate_block_id(&content, None, Some("tenant-a"));
let id_tenant_b = generate_block_id(&content, None, Some("tenant-b"));
assert_ne!(id_tenant_a, id_tenant_b);

// Same namespace = same ID
let id_tenant_a2 = generate_block_id(&content, None, Some("tenant-a"));
assert_eq!(id_tenant_a, id_tenant_a2);
```

## ID Generator

For repeated ID generation with consistent configuration:

```rust
use ucm_core::id::{IdGenerator, IdGeneratorConfig};
use ucm_core::Content;

// Create generator with configuration
let config = IdGeneratorConfig::new()
    .with_namespace("my-app")
    .with_semantic_role(true);

let generator = IdGenerator::new(config);

// Generate IDs
let content = Content::text("Hello");
let id = generator.generate(&content, Some("intro"));
```

### Configuration Options

```rust
pub struct IdGeneratorConfig {
    /// Namespace for multi-tenant scenarios
    pub namespace: Option<String>,
    
    /// Whether to include semantic role in hash
    pub include_semantic_role: bool,
}
```

## Content Hash

For full content hashing (SHA256):

```rust
use ucm_core::id::{compute_content_hash, ContentHash};
use ucm_core::Content;

let content = Content::text("Hello, world!");
let hash: ContentHash = compute_content_hash(&content);

println!("{}", hash); // Full 64 hex chars (256 bits)

// Access raw bytes
let bytes: &[u8; 32] = hash.as_bytes();
```

## Collision Resistance

With 96 bits of entropy:

- **Collision probability**: < 10⁻¹⁵ at 10 million blocks
- **Birthday bound**: ~2⁴⁸ blocks before 50% collision probability

This is sufficient for virtually all practical use cases.

## BlockId Operations

### Display and Debug

```rust
let id = BlockId::from_bytes([0x01; 12]);

// Display format
println!("{}", id); // blk_010101010101010101010101

// Debug format
println!("{:?}", id); // BlockId(blk_010101010101010101010101)
```

### Access Raw Bytes

```rust
let id = BlockId::from_bytes([0x01; 12]);
let bytes: &[u8; 12] = id.as_bytes();
```

### Root Detection

```rust
let root = BlockId::root();
assert!(root.is_root());

let regular = BlockId::from_bytes([0x01; 12]);
assert!(!regular.is_root());
```

### Serialization

```rust
use serde_json;

let id = BlockId::from_bytes([0x01; 12]);

// Serialize
let json = serde_json::to_string(&id).unwrap();
// "010101010101010101010101"

// Deserialize
let restored: BlockId = serde_json::from_str(&json).unwrap();
assert_eq!(id, restored);
```

## Content Normalization

Before hashing, content is normalized to ensure equivalent content produces identical IDs:

### Text Normalization

- **Unicode**: NFC normalization
- **Whitespace**: Collapsed to single spaces
- **Line endings**: Normalized to LF

```rust
use ucm_core::normalize::{normalize_text, NormalizationConfig, WhitespaceNorm};

// Default: collapse whitespace
let normalized = normalize_text("  hello   world  ", NormalizationConfig::default());
assert_eq!(normalized, "hello world");

// Preserve whitespace (for code)
let config = NormalizationConfig {
    whitespace: WhitespaceNorm::Preserve,
    ..Default::default()
};
let normalized = normalize_text("  hello   world  ", config);
assert_eq!(normalized, "  hello   world  ");
```

### Code Normalization

- **Whitespace**: Preserved
- **Line endings**: Normalized to LF
- **Language**: Lowercased

### JSON Normalization

- **Keys**: Sorted lexicographically
- **Whitespace**: Removed
- **Numbers**: Canonical form

```rust
use ucm_core::normalize::canonical_json;

let json = serde_json::json!({"b": 1, "a": 2});
let canonical = canonical_json(&json);
assert_eq!(canonical, r#"{"a":2,"b":1}"#);
```

## Complete Example

```rust
use ucm_core::{Block, Content, Document};
use ucm_core::id::{generate_block_id, compute_content_hash, IdGenerator, IdGeneratorConfig};

fn main() {
    // Direct ID generation
    let content = Content::text("Hello, world!");
    let id = generate_block_id(&content, Some("intro"), None);
    println!("Generated ID: {}", id);
    
    // With namespace
    let id_namespaced = generate_block_id(&content, Some("intro"), Some("my-app"));
    println!("Namespaced ID: {}", id_namespaced);
    assert_ne!(id, id_namespaced);
    
    // Using IdGenerator
    let generator = IdGenerator::new(
        IdGeneratorConfig::new().with_namespace("production")
    );
    let id = generator.generate(&content, Some("intro"));
    
    // Content hash for change detection
    let hash = compute_content_hash(&content);
    println!("Content hash: {}", hash);
    
    // In practice, Block::new handles ID generation
    let block = Block::new(content, Some("intro"));
    println!("Block ID: {}", block.id);
    
    // Verify determinism
    let block2 = Block::new(Content::text("Hello, world!"), Some("intro"));
    assert_eq!(block.id, block2.id);
}
```

## Best Practices

### 1. Use Semantic Roles for Differentiation

```rust
// Same content, different roles = different IDs
let intro = Block::new(Content::text("Hello"), Some("intro"));
let conclusion = Block::new(Content::text("Hello"), Some("conclusion"));
assert_ne!(intro.id, conclusion.id);
```

### 2. Use Namespaces for Multi-Tenancy

```rust
let config = IdGeneratorConfig::new()
    .with_namespace(&tenant_id);
let generator = IdGenerator::new(config);
```

### 3. Don't Rely on ID Format

```rust
// Good - use provided methods
let is_root = id.is_root();
let bytes = id.as_bytes();

// Avoid - parsing the string format
let s = id.to_string();
// Don't manually parse "blk_..."
```

### 4. Store IDs as Strings in External Systems

```rust
// For databases, APIs, etc.
let id_string = block.id.to_string();

// Restore later
let id: BlockId = id_string.parse().unwrap();
```

## See Also

- [Blocks](./blocks.md) - Block structure
- [Content Types](./content-types.md) - Content variants
- [Metadata](./metadata.md) - Content hash in metadata
