# Implementation Plan: Rust Core + PyO3/wasm-bindgen Bindings

## Overview

Replace the three separate implementations (Rust, Python, JS) with a single Rust core that exposes bindings to Python (via PyO3) and JavaScript (via wasm-bindgen).

## Crate Structure

```
crates/
  ucm-core/           # Pure Rust (unchanged)
  ucm-engine/         # Pure Rust (unchanged)
  ucl-parser/         # Pure Rust (unchanged)
  ucp-api/            # Pure Rust (unchanged)
  ucp-python/         # NEW: PyO3 bindings
  ucp-wasm/           # NEW: wasm-bindgen bindings
```

## Phase 1: Scaffolding

### 1.1 Create `crates/ucp-python/`

**Files:**
- `Cargo.toml` - PyO3 dependencies, cdylib crate type
- `pyproject.toml` - maturin build config
- `src/lib.rs` - Module exports and PyO3 init
- `src/types.rs` - BlockId, ContentType, EdgeType wrappers
- `src/content.rs` - Content enum wrapper with factory methods
- `src/block.rs` - Block wrapper
- `src/document.rs` - Document wrapper
- `src/engine.rs` - Engine/UCL execution wrapper
- `src/errors.rs` - Exception hierarchy
- `python/ucp/__init__.py` - Re-exports
- `python/ucp/_core.pyi` - Type stubs

### 1.2 Create `crates/ucp-wasm/`

**Files:**
- `Cargo.toml` - wasm-bindgen dependencies
- `src/lib.rs` - Module exports and wasm init
- `src/types.rs` - Type wrappers
- `src/document.rs` - Document bindings
- `src/errors.rs` - Error conversion

### 1.3 Update workspace `Cargo.toml`

Add new crates to workspace members.

## Phase 2: Core Type Bindings

### 2.1 Python Type Wrappers

```rust
// BlockId wrapper
#[pyclass(name = "BlockId")]
pub struct PyBlockId(pub(crate) ucm_core::BlockId);

// ContentType enum
#[pyclass(eq, eq_int)]
pub enum PyContentType { Text, Code, Table, Math, Media, Json, Binary, Composite }

// EdgeType enum
#[pyclass(eq, eq_int)]
pub enum PyEdgeType { DerivedFrom, References, Supports, ... }

// Content with factory methods
#[pyclass(name = "Content")]
pub struct PyContent(pub(crate) ucm_core::Content);

#[pymethods]
impl PyContent {
    #[staticmethod]
    fn text(s: &str) -> Self { ... }
    #[staticmethod]
    fn code(lang: &str, source: &str) -> Self { ... }
    #[staticmethod]
    fn markdown(s: &str) -> Self { ... }
}
```

### 2.2 WASM Type Wrappers

```rust
#[wasm_bindgen]
pub struct Content { inner: ucm_core::Content }

#[wasm_bindgen]
impl Content {
    #[wasm_bindgen(js_name = text)]
    pub fn text(s: &str) -> Content { ... }
}
```

## Phase 3: Document & Block Bindings

### 3.1 Python Document

```rust
#[pyclass(name = "Document")]
pub struct PyDocument {
    inner: ucm_core::Document,
}

#[pymethods]
impl PyDocument {
    #[staticmethod]
    fn create(title: Option<&str>) -> Self { ... }

    #[getter]
    fn root_id(&self) -> PyBlockId { ... }

    fn add_block(&mut self, parent_id: &PyBlockId, content: &str, ...) -> PyResult<PyBlockId> { ... }
    fn get_block(&self, id: &PyBlockId) -> Option<PyBlock> { ... }
    fn edit_block(&mut self, id: &PyBlockId, content: &str) -> PyResult<()> { ... }
    fn move_block(&mut self, id: &PyBlockId, new_parent: &PyBlockId, index: Option<usize>) -> PyResult<()> { ... }
    fn delete_block(&mut self, id: &PyBlockId, cascade: Option<bool>) -> PyResult<()> { ... }

    fn children(&self, parent_id: &PyBlockId) -> Vec<PyBlockId> { ... }
    fn parent(&self, child_id: &PyBlockId) -> Option<PyBlockId> { ... }
    fn ancestors(&self, id: &PyBlockId) -> Vec<PyBlockId> { ... }
    fn descendants(&self, id: &PyBlockId) -> Vec<PyBlockId> { ... }

    fn add_tag(&mut self, id: &PyBlockId, tag: &str) -> PyResult<()> { ... }
    fn add_edge(&mut self, source: &PyBlockId, edge_type: PyEdgeType, target: &PyBlockId) -> PyResult<()> { ... }

    fn block_count(&self) -> usize { ... }
    fn to_json(&self) -> PyResult<String> { ... }
}
```

### 3.2 WASM Document

Similar structure using `#[wasm_bindgen]` attributes and `JsValue` for complex returns.

## Phase 4: Engine & UCL Bindings

### 4.1 UCL Execution

```rust
// Python
#[pyfunction]
fn execute_ucl(doc: &mut PyDocument, ucl: &str) -> PyResult<Vec<PyBlockId>> {
    let client = ucp_api::UcpClient::new();
    let results = client.execute_ucl(&mut doc.inner, ucl).into_py_result()?;
    // Extract affected block IDs
    Ok(results.iter().flat_map(|r| r.affected_blocks.iter().map(|id| PyBlockId(id.clone()))).collect())
}

// WASM
#[wasm_bindgen(js_name = executeUcl)]
pub fn execute_ucl(doc: &mut Document, ucl: &str) -> Result<js_sys::Array, JsValue> { ... }
```

### 4.2 Markdown Integration

```rust
#[pyfunction]
fn parse_markdown(md: &str) -> PyResult<PyDocument> {
    let doc = ucp_translator_markdown::parse(md).into_py_result()?;
    Ok(PyDocument { inner: doc })
}

#[pyfunction]
fn render_markdown(doc: &PyDocument) -> PyResult<String> {
    ucp_translator_markdown::render(&doc.inner).into_py_result()
}
```

## Phase 5: Error Handling

### Python Exceptions

```rust
pyo3::create_exception!(ucp, UcpError, PyException);
pyo3::create_exception!(ucp, BlockNotFoundError, UcpError);
pyo3::create_exception!(ucp, InvalidBlockIdError, UcpError);
pyo3::create_exception!(ucp, ParseError, UcpError);
pyo3::create_exception!(ucp, ValidationError, UcpError);

fn convert_error(err: ucm_core::Error) -> PyErr {
    match err {
        Error::BlockNotFound(id) => BlockNotFoundError::new_err(...),
        Error::InvalidBlockId(id) => InvalidBlockIdError::new_err(...),
        // ...
    }
}
```

### WASM Errors

Convert to `JsValue` with structured error objects containing `code`, `message`, `blockId`.

## Phase 6: LLM Utilities

### IdMapper

```rust
#[pyclass]
pub struct PyIdMapper { ... }

#[pymethods]
impl PyIdMapper {
    #[staticmethod]
    fn from_document(doc: &PyDocument) -> Self { ... }
    fn shorten(&self, text: &str) -> String { ... }
    fn expand(&self, text: &str) -> String { ... }
}
```

### PromptBuilder

```rust
#[pyclass]
pub struct PyPromptBuilder { ... }

#[pymethods]
impl PyPromptBuilder {
    #[new]
    fn new() -> Self { ... }
    fn edit(&mut self) -> &mut Self { ... }
    fn append(&mut self) -> &mut Self { ... }
    fn with_short_ids(&mut self) -> &mut Self { ... }
    fn build(&self) -> String { ... }
}
```

## Build Configuration

### Python (maturin)

```toml
# crates/ucp-python/pyproject.toml
[build-system]
requires = ["maturin>=1.4,<2.0"]
build-backend = "maturin"

[project]
name = "ucp-core"
version = "0.1.5"
requires-python = ">=3.8"

[tool.maturin]
features = ["pyo3/extension-module"]
module-name = "ucp._core"
```

### WASM (wasm-pack)

```bash
cd crates/ucp-wasm && wasm-pack build --target web
```

## Files to Create/Modify

### New Files

| Path | Purpose |
|------|---------|
| `crates/ucp-python/Cargo.toml` | PyO3 crate config |
| `crates/ucp-python/pyproject.toml` | maturin build |
| `crates/ucp-python/src/lib.rs` | Module entry |
| `crates/ucp-python/src/types.rs` | Type wrappers |
| `crates/ucp-python/src/content.rs` | Content bindings |
| `crates/ucp-python/src/block.rs` | Block bindings |
| `crates/ucp-python/src/document.rs` | Document bindings |
| `crates/ucp-python/src/engine.rs` | UCL execution |
| `crates/ucp-python/src/errors.rs` | Exceptions |
| `crates/ucp-python/src/llm.rs` | IdMapper, PromptBuilder |
| `crates/ucp-python/python/ucp/__init__.py` | Re-exports |
| `crates/ucp-wasm/Cargo.toml` | wasm-bindgen config |
| `crates/ucp-wasm/src/lib.rs` | WASM entry |
| `crates/ucp-wasm/src/types.rs` | Type bindings |
| `crates/ucp-wasm/src/document.rs` | Document bindings |
| `crates/ucp-wasm/src/errors.rs` | Error handling |

### Modified Files

| Path | Change |
|------|--------|
| `Cargo.toml` | Add ucp-python, ucp-wasm to workspace members |

## Verification

1. **Build Python bindings**: `cd crates/ucp-python && maturin develop`
2. **Run Python tests**: `pytest crates/ucp-python/tests/`
3. **Build WASM**: `cd crates/ucp-wasm && wasm-pack build --target web`
4. **Run WASM tests**: `cd crates/ucp-wasm && wasm-pack test --headless --chrome`
5. **API compatibility test**: Verify bindings match existing SDK APIs

## Implementation Order

1. Create crate scaffolding and Cargo configs
2. Implement BlockId, ContentType, EdgeType wrappers
3. Implement Content with factory methods
4. Implement Block wrapper
5. Implement Document wrapper with all methods
6. Implement UCL execution and markdown
7. Implement error handling
8. Implement LLM utilities (IdMapper, PromptBuilder)
9. Add type stubs and documentation
10. Create compatibility tests
